@inject IHttpService _httpService
@inject IJSRuntime JS
@implements IDisposable
@inject IDataCacheService _dataCatcheService

<section class="recommends">
    @if (_personalRecommends.Any())
    {
        <h2>随机推荐</h2>
    }
    <div class="recommends-group">
        @foreach (var item in _personalRecommends)
        {
            <div class="recommends-item">
                @if (item.DisplayType == PersonalRecommendDisplayType.PlainText)
                {
                    <PlainTextCard Model="item" />
                }
            </div>
        }
    </div>
    @if (loading)
    {
        <CnGalWebSite.Shared.MasaComponent.Shared.Cards.ProgressingCard Class="mt-8" />
    }
</section>



@code {
    List<PersonalRecommendModel> _personalRecommends { get; set; } = new List<PersonalRecommendModel>();

    bool loading;

    [CascadingParameter]
    public ErrorHandler ErrorHandler { get; set; }

    private DotNetObjectReference<MainCard> objRef;

    bool firstRender;

    protected override async Task OnInitializedAsync()
    {
        if (firstRender)
        {
            return;
        }
        firstRender = true;

        objRef = DotNetObjectReference.Create(this);
        await TriggerDotNetInstanceMethod();

        firstRender = false;
    }

    [JSInvokable]
    public async Task LoadMore()
    {
        try
        {
            if(loading)
            {
                return;
            }
            loading = true;
            StateHasChanged();

            var result = await _httpService.PostAsync<IEnumerable<int>, List<PersonalRecommendModel>>("api/home/GetPersonalizedRecommendations", _personalRecommends.Select(s=>s.Id));
            _personalRecommends.AddRange(result);

            loading = false;
            StateHasChanged();

        }
        catch (Exception ex)
        {
            ErrorHandler.ProcessError(ex, "获取个性化推荐失败");
        }
    }




    public async Task TriggerDotNetInstanceMethod()
    {
        try
        {
            await JS.InvokeAsync<string>("initInfiniteScroll", objRef);
        }
        catch
        {

        }
    }
    public void Dispose()
    {
        objRef?.Dispose();
    }
}
